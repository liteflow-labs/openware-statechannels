/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { EventFragment, FunctionFragment, Result } from "@ethersproject/abi";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  CallOverrides,
  ContractTransaction,
  ethers,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
} from "ethers";
import type { TypedEvent, TypedEventFilter, TypedListener } from "./common";

interface NitroAdjudicatorInterface extends ethers.utils.Interface {
  functions: {
    "_computeNewAllocation(uint256,tuple[],uint256[])": FunctionFragment;
    "_computeNewAllocationWithGuarantee(uint256,tuple[],uint256[],tuple)": FunctionFragment;
    "challenge(tuple,uint48,tuple[],uint8,tuple[],uint8[],tuple)": FunctionFragment;
    "checkpoint(tuple,uint48,tuple[],uint8,tuple[],uint8[])": FunctionFragment;
    "claim(uint256,bytes32,bytes,bytes32,bytes,bytes32,uint256[])": FunctionFragment;
    "conclude(uint48,tuple,bytes32,bytes32,uint8,uint8[],tuple[])": FunctionFragment;
    "concludeAndTransferAllAssets(uint48,tuple,bytes32,bytes,uint8,uint8[],tuple[])": FunctionFragment;
    "deposit(address,bytes32,uint256,uint256)": FunctionFragment;
    "getChainID()": FunctionFragment;
    "holdings(address,bytes32)": FunctionFragment;
    "requireValidInput(uint256,uint256,uint256,uint256)": FunctionFragment;
    "respond(bool[2],tuple,tuple[2],tuple)": FunctionFragment;
    "statusOf(bytes32)": FunctionFragment;
    "transfer(uint256,bytes32,bytes,bytes32,uint256[])": FunctionFragment;
    "transferAllAssets(bytes32,bytes,bytes32)": FunctionFragment;
    "unpackStatus(bytes32)": FunctionFragment;
    "validTransition(uint256,bool[2],tuple[2],uint48,address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "_computeNewAllocation",
    values: [
      BigNumberish,
      { destination: BytesLike; amount: BigNumberish }[],
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_computeNewAllocationWithGuarantee",
    values: [
      BigNumberish,
      { destination: BytesLike; amount: BigNumberish }[],
      BigNumberish[],
      { targetChannelId: BytesLike; destinations: BytesLike[] }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "challenge",
    values: [
      {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      BigNumberish,
      { outcome: BytesLike; appData: BytesLike }[],
      BigNumberish,
      { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      BigNumberish[],
      { v: BigNumberish; r: BytesLike; s: BytesLike }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "checkpoint",
    values: [
      {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      BigNumberish,
      { outcome: BytesLike; appData: BytesLike }[],
      BigNumberish,
      { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claim",
    values: [
      BigNumberish,
      BytesLike,
      BytesLike,
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "conclude",
    values: [
      BigNumberish,
      {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish[],
      { v: BigNumberish; r: BytesLike; s: BytesLike }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "concludeAndTransferAllAssets",
    values: [
      BigNumberish,
      {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish[],
      { v: BigNumberish; r: BytesLike; s: BytesLike }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [string, BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "holdings",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "requireValidInput",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "respond",
    values: [
      [boolean, boolean],
      {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      { v: BigNumberish; r: BytesLike; s: BytesLike }
    ]
  ): string;
  encodeFunctionData(functionFragment: "statusOf", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [BigNumberish, BytesLike, BytesLike, BytesLike, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAllAssets",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unpackStatus",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validTransition",
    values: [
      BigNumberish,
      [boolean, boolean],
      [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      BigNumberish,
      string
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "_computeNewAllocation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_computeNewAllocationWithGuarantee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "challenge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkpoint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "conclude", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "concludeAndTransferAllAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getChainID", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "holdings", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "requireValidInput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "respond", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "statusOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferAllAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpackStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validTransition",
    data: BytesLike
  ): Result;

  events: {
    "AllocationUpdated(bytes32,uint256,uint256)": EventFragment;
    "ChallengeCleared(bytes32,uint48)": EventFragment;
    "ChallengeRegistered(bytes32,uint48,uint48,bool,tuple,tuple[],tuple[],uint8[])": EventFragment;
    "Concluded(bytes32,uint48)": EventFragment;
    "Deposited(bytes32,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AllocationUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChallengeCleared"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChallengeRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Concluded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
}

export type AllocationUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    channelId: string;
    assetIndex: BigNumber;
    initialHoldings: BigNumber;
  }
>;

export type ChallengeClearedEvent = TypedEvent<
  [string, number] & { channelId: string; newTurnNumRecord: number }
>;

export type ChallengeRegisteredEvent = TypedEvent<
  [
    string,
    number,
    number,
    boolean,
    [BigNumber, string[], number, string, number] & {
      chainId: BigNumber;
      participants: string[];
      channelNonce: number;
      appDefinition: string;
      challengeDuration: number;
    },
    ([string, string] & { outcome: string; appData: string })[],
    ([number, string, string] & { v: number; r: string; s: string })[],
    number[]
  ] & {
    channelId: string;
    turnNumRecord: number;
    finalizesAt: number;
    isFinal: boolean;
    fixedPart: [BigNumber, string[], number, string, number] & {
      chainId: BigNumber;
      participants: string[];
      channelNonce: number;
      appDefinition: string;
      challengeDuration: number;
    };
    variableParts: ([string, string] & { outcome: string; appData: string })[];
    sigs: ([number, string, string] & { v: number; r: string; s: string })[];
    whoSignedWhat: number[];
  }
>;

export type ConcludedEvent = TypedEvent<
  [string, number] & { channelId: string; finalizesAt: number }
>;

export type DepositedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber] & {
    destination: string;
    asset: string;
    amountDeposited: BigNumber;
    destinationHoldings: BigNumber;
  }
>;

export class NitroAdjudicator extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: NitroAdjudicatorInterface;

  functions: {
    _computeNewAllocation(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber] & { destination: string; amount: BigNumber })[],
        boolean,
        BigNumber[],
        BigNumber
      ] & {
        newAllocation: ([string, BigNumber] & {
          destination: string;
          amount: BigNumber;
        })[];
        allocatesOnlyZeros: boolean;
        payouts: BigNumber[];
        totalPayouts: BigNumber;
      }
    >;

    _computeNewAllocationWithGuarantee(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      guarantee: { targetChannelId: BytesLike; destinations: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber] & { destination: string; amount: BigNumber })[],
        boolean,
        BigNumber
      ] & {
        newAllocation: ([string, BigNumber] & {
          destination: string;
          amount: BigNumber;
        })[];
        allocatesOnlyZeros: boolean;
        totalPayouts: BigNumber;
      }
    >;

    challenge(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      challengerSig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkpoint(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claim(
      assetIndex: BigNumberish,
      guarantorChannelId: BytesLike,
      guarantorOutcomeBytes: BytesLike,
      guarantorStateHash: BytesLike,
      targetOutcomeBytes: BytesLike,
      targetStateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    conclude(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeHash: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    concludeAndTransferAllAssets(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeBytes: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    deposit(
      asset: string,
      channelId: BytesLike,
      expectedHeld: BigNumberish,
      amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getChainID(overrides?: CallOverrides): Promise<[BigNumber]>;

    holdings(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    requireValidInput(
      numParticipants: BigNumberish,
      numStates: BigNumberish,
      numSigs: BigNumberish,
      numWhoSignedWhats: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    respond(
      isFinalAB: [boolean, boolean],
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      variablePartAB: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      sig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    statusOf(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    transfer(
      assetIndex: BigNumberish,
      fromChannelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferAllAssets(
      channelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unpackStatus(
      channelId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [number, number, BigNumber] & {
        turnNumRecord: number;
        finalizesAt: number;
        fingerprint: BigNumber;
      }
    >;

    validTransition(
      nParticipants: BigNumberish,
      isFinalAB: [boolean, boolean],
      ab: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      turnNumB: BigNumberish,
      appDefinition: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  _computeNewAllocation(
    initialHoldings: BigNumberish,
    allocation: { destination: BytesLike; amount: BigNumberish }[],
    indices: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, BigNumber] & { destination: string; amount: BigNumber })[],
      boolean,
      BigNumber[],
      BigNumber
    ] & {
      newAllocation: ([string, BigNumber] & {
        destination: string;
        amount: BigNumber;
      })[];
      allocatesOnlyZeros: boolean;
      payouts: BigNumber[];
      totalPayouts: BigNumber;
    }
  >;

  _computeNewAllocationWithGuarantee(
    initialHoldings: BigNumberish,
    allocation: { destination: BytesLike; amount: BigNumberish }[],
    indices: BigNumberish[],
    guarantee: { targetChannelId: BytesLike; destinations: BytesLike[] },
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, BigNumber] & { destination: string; amount: BigNumber })[],
      boolean,
      BigNumber
    ] & {
      newAllocation: ([string, BigNumber] & {
        destination: string;
        amount: BigNumber;
      })[];
      allocatesOnlyZeros: boolean;
      totalPayouts: BigNumber;
    }
  >;

  challenge(
    fixedPart: {
      chainId: BigNumberish;
      participants: string[];
      channelNonce: BigNumberish;
      appDefinition: string;
      challengeDuration: BigNumberish;
    },
    largestTurnNum: BigNumberish,
    variableParts: { outcome: BytesLike; appData: BytesLike }[],
    isFinalCount: BigNumberish,
    sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    whoSignedWhat: BigNumberish[],
    challengerSig: { v: BigNumberish; r: BytesLike; s: BytesLike },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkpoint(
    fixedPart: {
      chainId: BigNumberish;
      participants: string[];
      channelNonce: BigNumberish;
      appDefinition: string;
      challengeDuration: BigNumberish;
    },
    largestTurnNum: BigNumberish,
    variableParts: { outcome: BytesLike; appData: BytesLike }[],
    isFinalCount: BigNumberish,
    sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    whoSignedWhat: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claim(
    assetIndex: BigNumberish,
    guarantorChannelId: BytesLike,
    guarantorOutcomeBytes: BytesLike,
    guarantorStateHash: BytesLike,
    targetOutcomeBytes: BytesLike,
    targetStateHash: BytesLike,
    indices: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  conclude(
    largestTurnNum: BigNumberish,
    fixedPart: {
      chainId: BigNumberish;
      participants: string[];
      channelNonce: BigNumberish;
      appDefinition: string;
      challengeDuration: BigNumberish;
    },
    appPartHash: BytesLike,
    outcomeHash: BytesLike,
    numStates: BigNumberish,
    whoSignedWhat: BigNumberish[],
    sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  concludeAndTransferAllAssets(
    largestTurnNum: BigNumberish,
    fixedPart: {
      chainId: BigNumberish;
      participants: string[];
      channelNonce: BigNumberish;
      appDefinition: string;
      challengeDuration: BigNumberish;
    },
    appPartHash: BytesLike,
    outcomeBytes: BytesLike,
    numStates: BigNumberish,
    whoSignedWhat: BigNumberish[],
    sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  deposit(
    asset: string,
    channelId: BytesLike,
    expectedHeld: BigNumberish,
    amount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getChainID(overrides?: CallOverrides): Promise<BigNumber>;

  holdings(
    arg0: string,
    arg1: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  requireValidInput(
    numParticipants: BigNumberish,
    numStates: BigNumberish,
    numSigs: BigNumberish,
    numWhoSignedWhats: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  respond(
    isFinalAB: [boolean, boolean],
    fixedPart: {
      chainId: BigNumberish;
      participants: string[];
      channelNonce: BigNumberish;
      appDefinition: string;
      challengeDuration: BigNumberish;
    },
    variablePartAB: [
      { outcome: BytesLike; appData: BytesLike },
      { outcome: BytesLike; appData: BytesLike }
    ],
    sig: { v: BigNumberish; r: BytesLike; s: BytesLike },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  statusOf(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  transfer(
    assetIndex: BigNumberish,
    fromChannelId: BytesLike,
    outcomeBytes: BytesLike,
    stateHash: BytesLike,
    indices: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferAllAssets(
    channelId: BytesLike,
    outcomeBytes: BytesLike,
    stateHash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unpackStatus(
    channelId: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [number, number, BigNumber] & {
      turnNumRecord: number;
      finalizesAt: number;
      fingerprint: BigNumber;
    }
  >;

  validTransition(
    nParticipants: BigNumberish,
    isFinalAB: [boolean, boolean],
    ab: [
      { outcome: BytesLike; appData: BytesLike },
      { outcome: BytesLike; appData: BytesLike }
    ],
    turnNumB: BigNumberish,
    appDefinition: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    _computeNewAllocation(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber] & { destination: string; amount: BigNumber })[],
        boolean,
        BigNumber[],
        BigNumber
      ] & {
        newAllocation: ([string, BigNumber] & {
          destination: string;
          amount: BigNumber;
        })[];
        allocatesOnlyZeros: boolean;
        payouts: BigNumber[];
        totalPayouts: BigNumber;
      }
    >;

    _computeNewAllocationWithGuarantee(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      guarantee: { targetChannelId: BytesLike; destinations: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber] & { destination: string; amount: BigNumber })[],
        boolean,
        BigNumber
      ] & {
        newAllocation: ([string, BigNumber] & {
          destination: string;
          amount: BigNumber;
        })[];
        allocatesOnlyZeros: boolean;
        totalPayouts: BigNumber;
      }
    >;

    challenge(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      challengerSig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    checkpoint(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    claim(
      assetIndex: BigNumberish,
      guarantorChannelId: BytesLike,
      guarantorOutcomeBytes: BytesLike,
      guarantorStateHash: BytesLike,
      targetOutcomeBytes: BytesLike,
      targetStateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    conclude(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeHash: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<void>;

    concludeAndTransferAllAssets(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeBytes: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      asset: string,
      channelId: BytesLike,
      expectedHeld: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getChainID(overrides?: CallOverrides): Promise<BigNumber>;

    holdings(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    requireValidInput(
      numParticipants: BigNumberish,
      numStates: BigNumberish,
      numSigs: BigNumberish,
      numWhoSignedWhats: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    respond(
      isFinalAB: [boolean, boolean],
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      variablePartAB: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      sig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    statusOf(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    transfer(
      assetIndex: BigNumberish,
      fromChannelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    transferAllAssets(
      channelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    unpackStatus(
      channelId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [number, number, BigNumber] & {
        turnNumRecord: number;
        finalizesAt: number;
        fingerprint: BigNumber;
      }
    >;

    validTransition(
      nParticipants: BigNumberish,
      isFinalAB: [boolean, boolean],
      ab: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      turnNumB: BigNumberish,
      appDefinition: string,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "AllocationUpdated(bytes32,uint256,uint256)"(
      channelId?: BytesLike | null,
      assetIndex?: null,
      initialHoldings?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { channelId: string; assetIndex: BigNumber; initialHoldings: BigNumber }
    >;

    AllocationUpdated(
      channelId?: BytesLike | null,
      assetIndex?: null,
      initialHoldings?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { channelId: string; assetIndex: BigNumber; initialHoldings: BigNumber }
    >;

    "ChallengeCleared(bytes32,uint48)"(
      channelId?: BytesLike | null,
      newTurnNumRecord?: null
    ): TypedEventFilter<
      [string, number],
      { channelId: string; newTurnNumRecord: number }
    >;

    ChallengeCleared(
      channelId?: BytesLike | null,
      newTurnNumRecord?: null
    ): TypedEventFilter<
      [string, number],
      { channelId: string; newTurnNumRecord: number }
    >;

    "ChallengeRegistered(bytes32,uint48,uint48,bool,tuple,tuple[],tuple[],uint8[])"(
      channelId?: BytesLike | null,
      turnNumRecord?: null,
      finalizesAt?: null,
      isFinal?: null,
      fixedPart?: null,
      variableParts?: null,
      sigs?: null,
      whoSignedWhat?: null
    ): TypedEventFilter<
      [
        string,
        number,
        number,
        boolean,
        [BigNumber, string[], number, string, number] & {
          chainId: BigNumber;
          participants: string[];
          channelNonce: number;
          appDefinition: string;
          challengeDuration: number;
        },
        ([string, string] & { outcome: string; appData: string })[],
        ([number, string, string] & { v: number; r: string; s: string })[],
        number[]
      ],
      {
        channelId: string;
        turnNumRecord: number;
        finalizesAt: number;
        isFinal: boolean;
        fixedPart: [BigNumber, string[], number, string, number] & {
          chainId: BigNumber;
          participants: string[];
          channelNonce: number;
          appDefinition: string;
          challengeDuration: number;
        };
        variableParts: ([string, string] & {
          outcome: string;
          appData: string;
        })[];
        sigs: ([number, string, string] & {
          v: number;
          r: string;
          s: string;
        })[];
        whoSignedWhat: number[];
      }
    >;

    ChallengeRegistered(
      channelId?: BytesLike | null,
      turnNumRecord?: null,
      finalizesAt?: null,
      isFinal?: null,
      fixedPart?: null,
      variableParts?: null,
      sigs?: null,
      whoSignedWhat?: null
    ): TypedEventFilter<
      [
        string,
        number,
        number,
        boolean,
        [BigNumber, string[], number, string, number] & {
          chainId: BigNumber;
          participants: string[];
          channelNonce: number;
          appDefinition: string;
          challengeDuration: number;
        },
        ([string, string] & { outcome: string; appData: string })[],
        ([number, string, string] & { v: number; r: string; s: string })[],
        number[]
      ],
      {
        channelId: string;
        turnNumRecord: number;
        finalizesAt: number;
        isFinal: boolean;
        fixedPart: [BigNumber, string[], number, string, number] & {
          chainId: BigNumber;
          participants: string[];
          channelNonce: number;
          appDefinition: string;
          challengeDuration: number;
        };
        variableParts: ([string, string] & {
          outcome: string;
          appData: string;
        })[];
        sigs: ([number, string, string] & {
          v: number;
          r: string;
          s: string;
        })[];
        whoSignedWhat: number[];
      }
    >;

    "Concluded(bytes32,uint48)"(
      channelId?: BytesLike | null,
      finalizesAt?: null
    ): TypedEventFilter<
      [string, number],
      { channelId: string; finalizesAt: number }
    >;

    Concluded(
      channelId?: BytesLike | null,
      finalizesAt?: null
    ): TypedEventFilter<
      [string, number],
      { channelId: string; finalizesAt: number }
    >;

    "Deposited(bytes32,address,uint256,uint256)"(
      destination?: BytesLike | null,
      asset?: null,
      amountDeposited?: null,
      destinationHoldings?: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber],
      {
        destination: string;
        asset: string;
        amountDeposited: BigNumber;
        destinationHoldings: BigNumber;
      }
    >;

    Deposited(
      destination?: BytesLike | null,
      asset?: null,
      amountDeposited?: null,
      destinationHoldings?: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber],
      {
        destination: string;
        asset: string;
        amountDeposited: BigNumber;
        destinationHoldings: BigNumber;
      }
    >;
  };

  estimateGas: {
    _computeNewAllocation(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _computeNewAllocationWithGuarantee(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      guarantee: { targetChannelId: BytesLike; destinations: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    challenge(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      challengerSig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    checkpoint(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claim(
      assetIndex: BigNumberish,
      guarantorChannelId: BytesLike,
      guarantorOutcomeBytes: BytesLike,
      guarantorStateHash: BytesLike,
      targetOutcomeBytes: BytesLike,
      targetStateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    conclude(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeHash: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    concludeAndTransferAllAssets(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeBytes: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    deposit(
      asset: string,
      channelId: BytesLike,
      expectedHeld: BigNumberish,
      amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getChainID(overrides?: CallOverrides): Promise<BigNumber>;

    holdings(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    requireValidInput(
      numParticipants: BigNumberish,
      numStates: BigNumberish,
      numSigs: BigNumberish,
      numWhoSignedWhats: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    respond(
      isFinalAB: [boolean, boolean],
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      variablePartAB: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      sig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    statusOf(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      assetIndex: BigNumberish,
      fromChannelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferAllAssets(
      channelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unpackStatus(
      channelId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    validTransition(
      nParticipants: BigNumberish,
      isFinalAB: [boolean, boolean],
      ab: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      turnNumB: BigNumberish,
      appDefinition: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _computeNewAllocation(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _computeNewAllocationWithGuarantee(
      initialHoldings: BigNumberish,
      allocation: { destination: BytesLike; amount: BigNumberish }[],
      indices: BigNumberish[],
      guarantee: { targetChannelId: BytesLike; destinations: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    challenge(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      challengerSig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkpoint(
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      largestTurnNum: BigNumberish,
      variableParts: { outcome: BytesLike; appData: BytesLike }[],
      isFinalCount: BigNumberish,
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      whoSignedWhat: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claim(
      assetIndex: BigNumberish,
      guarantorChannelId: BytesLike,
      guarantorOutcomeBytes: BytesLike,
      guarantorStateHash: BytesLike,
      targetOutcomeBytes: BytesLike,
      targetStateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    conclude(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeHash: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    concludeAndTransferAllAssets(
      largestTurnNum: BigNumberish,
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      appPartHash: BytesLike,
      outcomeBytes: BytesLike,
      numStates: BigNumberish,
      whoSignedWhat: BigNumberish[],
      sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      asset: string,
      channelId: BytesLike,
      expectedHeld: BigNumberish,
      amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getChainID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    holdings(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    requireValidInput(
      numParticipants: BigNumberish,
      numStates: BigNumberish,
      numSigs: BigNumberish,
      numWhoSignedWhats: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    respond(
      isFinalAB: [boolean, boolean],
      fixedPart: {
        chainId: BigNumberish;
        participants: string[];
        channelNonce: BigNumberish;
        appDefinition: string;
        challengeDuration: BigNumberish;
      },
      variablePartAB: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      sig: { v: BigNumberish; r: BytesLike; s: BytesLike },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    statusOf(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transfer(
      assetIndex: BigNumberish,
      fromChannelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      indices: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferAllAssets(
      channelId: BytesLike,
      outcomeBytes: BytesLike,
      stateHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unpackStatus(
      channelId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    validTransition(
      nParticipants: BigNumberish,
      isFinalAB: [boolean, boolean],
      ab: [
        { outcome: BytesLike; appData: BytesLike },
        { outcome: BytesLike; appData: BytesLike }
      ],
      turnNumB: BigNumberish,
      appDefinition: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
